Смена экранов с возможностью последующего возврата к ним

`[Описание проблемы]
Потребность в подобной схеме может возникнуть, например, при переходе с
экрана главного меню в экран настроек (если для этих целей будут
предусмотрены разные экраны). В этом случае экран, теряющий активность,
создаёт новый экран, тип которого поддерживает метод, например, `.void
setPreviousScreen(Screen item)`, и затем вызовом метода 
`..setActiveScreen(...)` класса `.GameCanvas` лишается возможности
обновляться в методах update и paint, однако при этом сохраняется в
памяти посредством ссылки на него из нового экрана. Впоследствии экран
может быть вызван к жизни передачей его в метод setActiveScreen класса
`.GameCanvas`, после чего другой экран уничтожается. Таким образом можно
организовать стек экранов.

`@
`{::label}Screen`
`{::label}GameCanvas`
`{::label}Основные потоки программы`